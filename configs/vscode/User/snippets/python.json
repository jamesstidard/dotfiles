{
	// Place your snippets for python here. Each snippet is defined under a snippet name and has a prefix, body and
	// description. The prefix is what is used to trigger the snippet and the body will be expanded and inserted. Possible variables are:
	// $1, $2 for tab stops, $0 for the final cursor position, and ${1:label}, ${2:another} for placeholders. Placeholders with the
	// same ids are connected.
	// Example:
	// "Print to console": {
	// 	"prefix": "log",
	// 	"body": [
	// 		"console.log('$1');",
	// 		"$2"
	// 	],
	// 	"description": "Log output to console"
	// }
	"Async Main": {
		"prefix": "defasyncmain",
		"body": [
			"import asyncio",
			"",
			"",
			"async def main():",
			"    ${1:pass}",
			"",
			"",
			"if __name__ == \"__main__\":",
    		"    asyncio.run(main())"
		],
	},
	"Main": {
		"prefix": "defmain",
		"body": [
			"def main():",
			"    ${1:pass}",
			"",
			"",
			"if __name__ == \"__main__\":",
    		"    main()",
		],
	},
	"Benchmark Context Manager": {
		"prefix": "defbenchmark",
		"body": [
			"@contextmanager",
			"def benchmark(name):",
			"    \"\"\"Prints the elapsed time of the code within the \"with\" statement.\"\"\"",
			"    start = time.time()",
			"    print(f\"STARTING: {name}\")",
			"    yield",
			"    end = time.time()",
			"    elapsed = (end - start)",
			"    print(f\"STOPPING: {name} (ELAPSED: {elapsed:.1f} seconds)\"",
		],
	},
	"Chunk Iterable": {
		"prefix": "defchunks",
		"body": [
			"def chunks(l, *, size):",
			"    \"\"\"Yield successive n-sized chunks from l.\"\"\"",
			"    for i in range(0, len(l), size):",
			"        yield l[i:i + size]",
		],
	},
	"Rotate Iterable": {
		"prefix": "defrotate",
		"body": [
			"def rotate(iterable, n):",
			"    iterable = deque(iterable)",
			"    iterable.rotate(n)",
			"    return list(iterable)",
		]
	},
	"Float Range": {
		"prefix": "deffrange",
		"body": [
			"def frange(start, stop, step):",
			"    \"\"\"A range-like function for floats.\"\"\"",
			"    # Using decimals to iterate as floating points",
			"    # can produce some strange behaviour.",
			"    current = decimal.Decimal(str(start))",
			"    stop = decimal.Decimal(str(stop))",
			"    step = decimal.Decimal(str(step))",
			"    while current < stop:",
			"        yield float(current)",
			"        current += step",
		],
	},
	"Key Sorter": {
		"prefix": "defkeysorter",
		"body": [
			"def key_sorter(*key_order):",
			"    \"\"\"",
			"    Sort dictionary keys by provided order.",
			"",
			"    This returns a function that cant be used as a key for a sort function,",
			"    such as `fn` in `sorted(a, key=fn)`.",
			"    \"\"\"",
			"    def column_index(dict_item):",
			"        key, _ = dict_item",
			"        try:",
			"            return key_order.index(key)",
			"        except ValueError:",
			"            return float(\"infinity\")",
			"    return column_index",
		],
	},
	"Merge Dicts": {
		"prefix": "defmerge",
		"body": [
			"def merge_dicts(*dicts):",
			"    \"\"\"",
			"    Merges dicts with right-most dict's value taking president.",
			"",
			"    :param dicts: The list of dicts to combine",
			"    :return: A new dict object",
			"    \"\"\"",
			"    all_keys  = set(k for d in dicts for k in d.keys())",
			"    chain_map = ChainMap(*reversed(dicts))",
			"    return {k: chain_map[k] for k in all_keys}",
		],
	},
	"String List Sentance": {
		"prefix": "defstrlist",
		"body": [
			"def str_list(items, oxford_comma=True, conjunctive=\"&\", quoted=True):",
			"    items = list(items)",
			"",
			"    if quoted:",
			"        items = [f'\"{i}\"' for i in items]",
			"",
			"    if len(items) <= 1:",
			"        return \"\".join(items)",
			"    else:",
			"        *head, tail = items",
			"",
			"        if oxford_comma:",
			"            tail = f\", {conjunctive} {tail}\"",
			"        else:",
			"            tail = f\" {conjunctive} {tail}\"",
			"",
			"        return \", \".join(head) + tail",
		],
	},
	"Redirect stdout": {
		"prefix": "stdoutr",
		"body": [
			"stdout = io.StringIO()",
			"with redirect_stdout(stdout):",
			"    ${1:pass}",
			"output = stdout.getvalue()",
		],
	},
	"Named Zip": {
		"prefix": "defnamedzip",
		"body": [
			"def named_zip(**kwargs):",
			"    result = namedtuple(\"result\", kwargs)",
			"",
			"    for items in zip(*kwargs.values()):",
			"        yield result(*items)"
		]
	},
	"All Equal": {
		"prefix": "defallequal",
		"body": [
			"def all_equal(l):",
    	"    return len(set(l)) in {0, 1}"
		]
	},
	"Snake Case": {
		"prefix": "defsnakecase",
		"body": [
			"def snake_case(name):",
			"    s1 = re.sub(\"(.)([A-Z][a-z]+)', r'\\1_\\2\", name)",
			"    return re.sub(\"([a-z0-9])([A-Z])', r'\\1_\\2\", s1).lower()"
		]
	},
	"CWD Context": {
		"prefix": "defcwd",
		"body": [
			"@contextmanager",
			"def cwd(wd):",
			"    previous_wd = os.getcwd()",
			"    os.chdir(wd)",
			"    try:",
			"        yield",
			"    finally:",
			"        os.chdir(previous_wd)"
		]
	},
	"Retry": {
		"prefix": "defretry",
		"body": [
			"def retry(fn, args=(), kwargs=(), max_attempts=3, allowed_exceptions=(Exception, )):",
			"    args = list(args)",
			"    kwargs = dict(kwargs)",
			"    allowed_exceptions = tuple(allowed_exceptions)",
			"",
			"    for attempt in itertools.count(start=1):",
			"        try:",
			"            return fn(*args, **kwargs)",
			"        except allowed_exceptions as e:",
			"            if attempt >= max_attempts:",
			"                raise e",
		]
	},
	"Engineering Notation": {
		"prefix": "defengineer",
		"body": [
			"def engineering_notation(value, precision=3):",
			"    fmt = \"{{:.{}g}}\".format(precision)",
			"    sci = fmt.format(value)",
			"    eng = decimal.Decimal(sci).to_eng_string()",
			"    eng = eng.lower()  # small e is nicer",
			"    return eng",
		]
	},
	"One": {
		"prefix": "defone",
		"body": [
			"RAISE = object()",
			"",
			"",
			"class TooFewError(ValueError):",
			"    pass",
			"",
			"",
			"class TooManyError(ValueError):",
			"    pass",
			"",
			"",
			"def one(i, default=RAISE):",
			"    \"\"\"",
			"    Acts like filter but asserts only a single element",
			"    is returned.",

			"    Raises a ValueError if more then one value returned",

			"    :param i: items to filter",
			"    :param default: the default value to return, if no item found (instead of raising)",
			"    \"\"\"",
			"    i = list(i)",
			"",
			"    if default is RAISE and len(i) == 0:",
			"        raise TooFewError(\"iterable is empty\")",
			"    elif default is RAISE and len(i) > 1:",
			"        raise TooManyError(\"iterable has more then one element\", i)",
			"    elif len(i) == 1:",
			"        return i[0]",
			"    else:",
			"        return default",
		]
	},
	"Text Block": {
		"prefix": "deftext_block",
		"body": ["def text_block(text):",
		"    r'''",
		"    Remove any common leading whitespace from every line in text.",
		"",
		"    This can be used to make triple-quoted strings line up with the left edge",
		"    of the display, while still presenting them in the source code in indented",
		"    form.",
		"",
		"    Similar to the standard library's `textwrap.dedent` but combining",
		"    all text on to a single line, apart from when there's a white-space",
		"    line (like markdown parsing).",
		"",
		"    >>> text_block(\"\"\"\\",
		"    Here is",
		"    some text.",
		"    Then a break",
		"",
		"    and some",
		"    more text",
		"    \"\"\")",
		"",
		"    ... Here is some text. Then a break",
		"    ...",
		"    ... and some more text",
		"    '''",
		"    text = textwrap.dedent(text)",
		"",
		"    output = \"\"",
		"    counter = itertools.count()",
		"    for line in text.splitlines():",
		"        idx = next(counter)",
		"",
		"        # remove trailing whitespace from line to prevent double spacing",
		"        # on line merge.",
		"        line = line.rstrip(\" \")",
		"",
		"        # add back in a single space for the line (apart from first line)",
		"        if idx != 0:",
		"            line = f\" {line}\"",
		"",
		"        # if line all whitespace, respect as new line",
		"        if line.rstrip(\" \") == \"\":",
		"            line = \"\\n\\n\"",
		"            # reset counter for no space on first line",
		"            counter = itertools.count()",
		"",
		"        output = output + line",
		"",
		"    return output",
		]
	},
	"Is ND Array": {
		"prefix": "defis_nd_array",
		"body": [
			"def is_nd_array(obj: object, allowed_types: [type]):",
			"    \"\"\"",
			"    Returns True or False depending if the object is a uniform",
			"    n-dimensional array. Where the arrays must be a python `list`.",
			"",
			"    obj: object to check",
			"    allowed_types: the types allowed for the cell values in the matrix",
			"    \"\"\"",
			"    allowed_types = tuple(allowed_types)",
			"",
			"    # must start as a list at least",
			"    if not isinstance(obj, list):",
			"        return False",
			"",
			"    # sentinel denoting depth end (i.e. cell value hit)",
			"    end = object()",
			"    # running state of what the current depths length must be to be",
			"    # uniform with the other lists at an equal depth, or if it must",
			"    # be a cell value AKA 'end' sentinel",
			"    depth_length = {}",
			"",
			"    def validate(target, depth=0):",
			"        if isinstance(target, list):",
			"            # first one here sets the length (setdefault)",
			"            # otherwise use previously set length for this depth",
			"            required_len = depth_length.setdefault(depth, len(target))",
			"",
			"            # all lists at given depth must be the same length",
			"            if len(target) != required_len:",
			"                return False",
			"",
			"            return all(validate(i, depth=depth + 1) for i in target)",
			"        else:",
			"            # all other items at this depth must also be cell values aka 'end'",
			"            required = depth_length.setdefault(depth, end)",
			"            if required is not end:",
			"                return False",
			"",
			"            # all values at the end of the lists must be in the allowed types",
			"            return isinstance(target, allowed_types)",
			"",
			"    return all(validate(i) for i in obj)",
		]
	},
	"Walk Object": {
		"prefix": "defwalk",
		"body": [
			"ANY = object()",
			"",
			"def walk(obj, *, types=ANY):",
			"    \"\"\"",
			"    Walks a object exhaustively and returns item path to the leaves found.",
			"",
			"    :param obj: the object graph to be searched",
			"    :param types: the types to limit the returned leaves or callable that returns boolean",
			"",
			"    :return generator yielding paths and leaf",
			"    \"\"\"",
			"    if callable(types):",
			"        predicate = types",
			"    elif types is ANY:",
			"        predicate = lambda: True",
			"    else:",
			"        predicate = lambda o: isinstance(o, types)",
			"",
			"    def dive(obj_, pre):",
			"        if types is not ANY and predicate(obj_):",
			"            yield pre, obj_",
			"        elif isinstance(obj_, dict):",
			"            for key, value in obj_.items():",
			"                yield from dive(value, [*pre, key])",
			"        elif isinstance(obj_, Mapping) and hasattr(obj_, \"items\"):",
			"            for key, value in obj_.items():",
			"                yield from dive(value, [*pre, key])",
			"        elif hasattr(obj_, \"_asdict\"):  # for namedtuple",
			"            for key, value in obj_._asdict().items():",
			"                yield from dive(value, [*pre, key])",
			"        elif hasattr(obj_, \"describe\"):",
			"            for name, value in obj_._describe().items():",
			"                yield from dive(value, [*pre, name])",
			"        elif isinstance(obj_, (list, set, tuple)):",
			"            for index, value in enumerate(obj_):",
			"                yield from dive(value, [*pre, index])",
			"        elif types is ANY:",
			"            yield pre, obj_",
			"",
			"    for path, leaf in dive(obj, []):",
			"        yield tuple(path), leaf",
		]
	},
	"Recursive Get/Set Operators": {
		"prefix": "defr",
		"body": [
			"RAISE = object()",
			"",
			"def rgetitem(obj, names, default=RAISE):",
			"    \"\"\"",
			"    Traverses the object by successively accessing each item in name.",
			"",
			"    :param obj: object to be traversed",
			"    :param names: list of item names to value",
			"    :param default: the default value to return if no path found",
			"    :return: value at path",
			"    \"\"\"",
			"    current = obj",
			"    for name in names:",
			"        try:",
			"            current = itemgetter(name)(current)",
			"        except (KeyError, IndexError, TypeError):",
			"            if default is RAISE:",
			"                raise",
			"            else:",
			"                return default",
			"    else:",
			"        return current",
			"",
			"def ritemgetter(names, default=RAISE):",
			"    return partial(rgetitem, names=names, default=default)",
			"",
			"def rsetitem(obj, names, value):",
			"    \"\"\"",
			"    Sets the value to item at the end of names of obj.",
			"",
			"    :param obj: object to be traversed",
			"    :param names: list of item names to value",
			"    :param value: value to be set at path",
			"    \"\"\"",
			"    try:",
			"        *path, item = names",
			"    except ValueError as e:",
			"        raise e",
			"    try:",
			"        rgetitem(obj, path)[item] = value",
			"    except (KeyError, ValueError) as e:",
			"        raise e",
		]
	}
}
